<% autogen_exception -%>
package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/dnaeon/go-vcr/cassette"
	"github.com/dnaeon/go-vcr/recorder"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
	"github.com/hashicorp/terraform-provider-google<%= "-" + version unless version == 'ga'  -%>/google<%= "-" + version unless version == 'ga'  -%>"
)

var TestAccProviders map[string]*schema.Provider
<% unless version == 'ga' -%>
var TestAccProvidersOiCS map[string]*schema.Provider
<% end -%>
var testAccProvider *schema.Provider




var projectNumberEnvVars = []string{
	"GOOGLE_PROJECT_NUMBER",
}

var firestoreProjectEnvVars = []string{
	"GOOGLE_FIRESTORE_PROJECT",
}






// This value is the Customer ID of the GOOGLE_ORG_DOMAIN workspace.
// See https://admin.google.com/ac/accountsettings when logged into an org admin for the value.
var custIdEnvVars = []string{
	"GOOGLE_CUST_ID",
}


// This value is the username of an identity account within the GOOGLE_ORG_DOMAIN workspace.
// For example in the org example.com with a user "foo@example.com", this would be set to "foo".
// See https://admin.google.com/ac/users when logged into an org admin for a list.
var identityUserEnvVars = []string{
	"GOOGLE_IDENTITY_USER",
}

var orgEnvDomainVars = []string{
	"GOOGLE_ORG_DOMAIN",
}

var serviceAccountEnvVars = []string{
	"GOOGLE_SERVICE_ACCOUNT",
}

var orgTargetEnvVars = []string{
	"GOOGLE_ORG_2",
}

var billingAccountEnvVars = []string{
	"GOOGLE_BILLING_ACCOUNT",
}

var configs map[string]*google.Config





var masterBillingAccountEnvVars = []string{
	"GOOGLE_MASTER_BILLING_ACCOUNT",
}

var configsLock = sync.RWMutex{}


func init() {
	configs = make(map[string]*google.Config)
	testAccProvider = Provider()
	<% if version == 'ga' -%>
	TestAccProviders = map[string]*schema.Provider{
		"google": testAccProvider,
	}
	<% else -%>
	TestAccProviders = map[string]*schema.Provider{
		"google": testAccProvider,
	}

	// The OiCS provider map is used to ensure that OiCS examples use `google-beta`
	// if the example is versioned as beta; normal beta tests should continue to
	// use the standard provider map.
	TestAccProvidersOiCS = map[string]*schema.Provider{
<%# Add a google-#{version} provider for each version that is supported by this version. This allows us to run google-beta tests within a google-alpha   -%>
<% Api::Product::Version::ORDER[1..Api::Product::Version::ORDER.index(version)].each do |aliased_version| -%>
		"google-<%= aliased_version -%>": testAccProvider,
<% end -%>
	}
	<% end -%>
}

// Returns a cached config if VCR testing is enabled. This enables us to use a single HTTP transport
// for a given test, allowing for recording of HTTP interactions.
// Why this exists: schema.Provider.ConfigureFunc is called multiple times for a given test
// ConfigureFunc on our provider creates a new HTTP client and sets base paths (config.go LoadAndValidate)
// VCR requires a single HTTP client to handle all interactions so it can record and replay responses so
// this caches HTTP clients per test by replacing ConfigureFunc
func getCachedConfig(ctx context.Context, d *schema.ResourceData, configureFunc schema.ConfigureContextFunc, testName string) (*google.Config, diag.Diagnostics) {
	configsLock.RLock()
	v, ok := configs[testName]
	configsLock.RUnlock()
	if ok {
		return v, nil
	}
	c, diags := configureFunc(ctx, d)
	if diags.HasError() {
		return nil, diags
	}
	config := c.(*google.Config)
	var vcrMode recorder.Mode
	switch vcrEnv := os.Getenv("VCR_MODE"); vcrEnv {
	case "RECORDING":
		vcrMode = recorder.ModeRecording
	case "REPLAYING":
		vcrMode = recorder.ModeReplaying
		// When replaying, set the poll interval low to speed up tests
		config.PollInterval = 10 * time.Millisecond
	default:
		log.Printf("[DEBUG] No valid environment var set for VCR_MODE, expected RECORDING or REPLAYING, skipping VCR. VCR_MODE: %s", vcrEnv)
		return config, nil
	}

	envPath := os.Getenv("VCR_PATH")
	if envPath == "" {
		log.Print("[DEBUG] No environment var set for VCR_PATH, skipping VCR")
		return config, nil
	}
	path := filepath.Join(envPath, google.VcrFileName(testName))

	rec, err := recorder.NewAsMode(path, vcrMode, config.Client.Transport)
	if err != nil {
		return nil, diag.FromErr(err)
	}
	// Defines how VCR will match requests to responses.
	rec.SetMatcher(func(r *http.Request, i cassette.Request) bool {
		// Default matcher compares method and URL only
		if !cassette.DefaultMatcher(r, i) {
			return false
		}
		if r.Body == nil {
			return true
		}
		contentType := r.Header.Get("Content-Type")
		// If body contains media, don't try to compare
		if strings.Contains(contentType, "multipart/related") {
			return true
		}

		var b bytes.Buffer
		if _, err := b.ReadFrom(r.Body); err != nil {
			log.Printf("[DEBUG] Failed to read request body from cassette: %v", err)
			return false
		}
		r.Body = ioutil.NopCloser(&b)
		reqBody := b.String()
		// If body matches identically, we are done
		if reqBody == i.Body {
			return true
		}

		// JSON might be the same, but reordered. Try parsing json and comparing
		if strings.Contains(contentType, "application/json") {
			var reqJson, cassetteJson interface{}
			if err := json.Unmarshal([]byte(reqBody), &reqJson); err != nil {
				log.Printf("[DEBUG] Failed to unmarshall request json: %v", err)
				return false
			}
			if err := json.Unmarshal([]byte(i.Body), &cassetteJson); err != nil {
				log.Printf("[DEBUG] Failed to unmarshall cassette json: %v", err)
				return false
			}
			return reflect.DeepEqual(reqJson, cassetteJson)
		}
		return false
	})
	config.Client.Transport = rec
	configsLock.Lock()
	configs[testName] = config
	configsLock.Unlock()
	return config, nil
}

// We need to explicitly close the VCR recorder to save the cassette
func closeRecorder(t *testing.T) {
	configsLock.RLock()
	config, ok := configs[t.Name()]
	configsLock.RUnlock()
	if ok {
		// We did not cache the config if it does not use VCR
		if !t.Failed() && google.IsVcrEnabled() {
			// If a test succeeds, write new seed/yaml to files
			err := config.Client.Transport.(*recorder.Recorder).Stop()
			if err != nil {
				t.Error(err)
			}
			envPath := os.Getenv("VCR_PATH")

			google.SourcesLock.RLock()
			vcrSource, ok := google.Sources[t.Name()]
			google.SourcesLock.RUnlock()
			if ok {
				err = writeSeedToFile(vcrSource.Seed, google.VcrSeedFile(envPath, t.Name()))
				if err != nil {
					t.Error(err)
				}
			}
		}
		// Clean up test config
		configsLock.Lock()
		delete(configs, t.Name())
		configsLock.Unlock()

		google.SourcesLock.Lock()
		delete(google.Sources, t.Name())
		google.SourcesLock.Unlock()
	}
}

func GoogleProviderConfig(t *testing.T) *google.Config {
	configsLock.RLock()
	config, ok := configs[t.Name()]
	configsLock.RUnlock()
	if ok {
		return config
	}
	return testAccProvider.Meta().(*google.Config)
}

func getTestAccProviders(testName string, c resource.TestCase) map[string]*schema.Provider {
	prov := Provider()
	if google.IsVcrEnabled() {
		old := prov.ConfigureContextFunc
		prov.ConfigureContextFunc = func(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
			return getCachedConfig(ctx, d, old, testName)
		}
	} else {
		log.Print("[DEBUG] VCR_PATH or VCR_MODE not set, skipping VCR")
	}
	var testProvider string
	providerMapKeys := reflect.ValueOf(c.Providers).MapKeys()
	if strings.Contains(providerMapKeys[0].String(), "google-beta") {
		testProvider = "google-beta"
	} else {
		testProvider = "google"
	}
	return map[string]*schema.Provider{
		testProvider: prov,
	}
}


// Wrapper for resource.Test to swap out providers for VCR providers and handle VCR specific things
// Can be called when VCR is not enabled, and it will behave as normal
func VcrTest(t *testing.T, c resource.TestCase) {
	if google.IsVcrEnabled() {
		providers := getTestAccProviders(t.Name(), c)
		c.Providers = providers
		defer closeRecorder(t)
	} else if isReleaseDiffEnabled() {
		c = initializeReleaseDiffTest(c)
	}
	resource.Test(t, c)
}






func writeSeedToFile(seed int64, fileName string) error {
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.WriteString(strconv.FormatInt(seed, 10))
	if err != nil {
		return err
	}
	return nil
}



func RandInt(t *testing.T) int {
	if !google.IsVcrEnabled() {
		return acctest.RandInt()
	}
	envPath := os.Getenv("VCR_PATH")
	vcrMode := os.Getenv("VCR_MODE")
	s, err := google.CreateVcrSource(t, envPath, vcrMode)
	if err != nil {
		// At this point we haven't created any resources, so fail fast
		t.Fatal(err)
	}

	return rand.New(s.Source).Int()
}

func TestProvider(t *testing.T) {
	if err := Provider().InternalValidate(); err != nil {
		t.Fatalf("err: %s", err)
	}
}

func TestProvider_impl(t *testing.T) {
	var _ *schema.Provider = Provider()
}

func TestProvider_noDuplicatesInResourceMap(t *testing.T) {
	_, err := ResourceMapWithErrors()
	if err != nil {
		t.Error(err)
	}
}

func TestAccPreCheck(t *testing.T) {
	if v := os.Getenv("GOOGLE_CREDENTIALS_FILE"); v != "" {
		creds, err := ioutil.ReadFile(v)
		if err != nil {
			t.Fatalf("Error reading GOOGLE_CREDENTIALS_FILE path: %s", err)
		}
		os.Setenv("GOOGLE_CREDENTIALS", string(creds))
	}

	if v := google.MultiEnvSearch(google.CredsEnvVars); v == "" {
		t.Fatalf("One of %s must be set for acceptance tests", strings.Join(google.CredsEnvVars, ", "))
	}

	if v := google.MultiEnvSearch(google.ProjectEnvVars); v == "" {
		t.Fatalf("One of %s must be set for acceptance tests", strings.Join(google.ProjectEnvVars, ", "))
	}

	if v := google.MultiEnvSearch(google.RegionEnvVars); v == "" {
		t.Fatalf("One of %s must be set for acceptance tests", strings.Join(google.RegionEnvVars, ", "))
	}

	if v := google.MultiEnvSearch(google.ZoneEnvVars); v == "" {
		t.Fatalf("One of %s must be set for acceptance tests", strings.Join(google.ZoneEnvVars, ", "))
	}
}

func TestProvider_getRegionFromZone(t *testing.T) {
	expected := "us-central1"
	actual := google.GetRegionFromZone("us-central1-f")
	if expected != actual {
		t.Fatalf("Region (%s) did not match expected value: %s", actual, expected)
	}
}


// getTestRegion has the same logic as the provider's GetRegion, to be used in tests.
func getTestRegion(is *terraform.InstanceState, config *google.Config) (string, error) {
	if res, ok := is.Attributes["region"]; ok {
		return res, nil
	}
	if config.Region != "" {
		return config.Region, nil
	}
	return "", fmt.Errorf("%q: required field is not set", "region")
}

// getTestProject has the same logic as the provider's GetProject, to be used in tests.
func getTestProject(is *terraform.InstanceState, config *google.Config) (string, error) {
	if res, ok := is.Attributes["project"]; ok {
		return res, nil
	}
	if config.Project != "" {
		return config.Project, nil
	}
	return "", fmt.Errorf("%q: required field is not set", "project")
}

// TestAccPreCheck ensures at least one of the project env variables is set.
func getTestProjectNumberFromEnv() string {
	return google.MultiEnvSearch(projectNumberEnvVars)
}






func getTestCustIdFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, custIdEnvVars...)
	return google.MultiEnvSearch(custIdEnvVars)
}

func getTestIdentityUserFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, identityUserEnvVars...)
	return google.MultiEnvSearch(identityUserEnvVars)
}

// Firestore can't be enabled at the same time as Datastore, so we need a new
// project to manage it until we can enable Firestore programmatically.
func getTestFirestoreProjectFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, firestoreProjectEnvVars...)
	return google.MultiEnvSearch(firestoreProjectEnvVars)
}


func getTestOrgDomainFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, orgEnvDomainVars...)
	return google.MultiEnvSearch(orgEnvDomainVars)
}

func getTestOrgTargetFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, orgTargetEnvVars...)
	return google.MultiEnvSearch(orgTargetEnvVars)
}

func GetTestBillingAccountFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, billingAccountEnvVars...)
	return google.MultiEnvSearch(billingAccountEnvVars)
}

func getTestMasterBillingAccountFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, masterBillingAccountEnvVars...)
	return google.MultiEnvSearch(masterBillingAccountEnvVars)
}

func getTestServiceAccountFromEnv(t *testing.T) string {
	google.SkipIfEnvNotSet(t, serviceAccountEnvVars...)
	return google.MultiEnvSearch(serviceAccountEnvVars)
}

// Some tests fail during VCR. One common case is race conditions when creating resources.
// If a test config adds two fine-grained resources with the same parent it is undefined
// which will be created first, causing VCR to fail ~50% of the time
func SkipIfVcr(t *testing.T) {
	if google.IsVcrEnabled() {
		t.Skipf("VCR enabled, skipping test: %s", t.Name())
	}
}

func sleepInSecondsForTest(t int) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		time.Sleep(time.Duration(t) * time.Second)
		return nil
	}
}



func isReleaseDiffEnabled() bool {
	releaseDiff := os.Getenv("RELEASE_DIFF")
	return releaseDiff != ""
}

func initializeReleaseDiffTest(c resource.TestCase) resource.TestCase {
	var releaseProvider string
	packagePath := fmt.Sprint(reflect.TypeOf(google.Config{}).PkgPath())
	if strings.Contains(packagePath, "google-beta") {
		releaseProvider = "google-beta"
	} else {
		releaseProvider = "google"
	}

	if c.ExternalProviders != nil {
		c.ExternalProviders[releaseProvider] = resource.ExternalProvider{}
	} else {
		c.ExternalProviders = map[string]resource.ExternalProvider{
			releaseProvider: {},
		}
	}

	localProviderName := "google-local"
	localProvider := map[string]*schema.Provider{
		localProviderName: testAccProvider,
	}
	c.Providers = localProvider

	var replacementSteps []resource.TestStep
	for _, testStep := range c.Steps {
		if testStep.Config != "" {
			ogConfig := testStep.Config
			testStep.Config = reformConfigWithProvider(ogConfig, localProviderName)
			if testStep.ExpectError == nil && testStep.PlanOnly == false {
				newStep := resource.TestStep{
					Config: reformConfigWithProvider(ogConfig, releaseProvider),
				}
				testStep.PlanOnly = true
				testStep.ExpectNonEmptyPlan = false
				replacementSteps = append(replacementSteps, newStep)
			}
			replacementSteps = append(replacementSteps, testStep)
		} else {
			replacementSteps = append(replacementSteps, testStep)
		}
	}

	c.Steps = replacementSteps

	return c
}

func reformConfigWithProvider(config, provider string) string {
	configBytes := []byte(config)
	providerReplacement := fmt.Sprintf("provider = %s", provider)
	providerReplacementBytes := []byte(providerReplacement)
	providerBlock := regexp.MustCompile(`provider *=.*google-beta.*`)

	if providerBlock.Match(configBytes) {
		return string(providerBlock.ReplaceAll(configBytes, providerReplacementBytes))
	}

	providerReplacement = fmt.Sprintf("${1}\n\t%s", providerReplacement)
	providerReplacementBytes = []byte(providerReplacement)
	resourceHeader := regexp.MustCompile(`(resource .*google_.* .*\w+.*\{.*)`)
	return string(resourceHeader.ReplaceAll(configBytes, providerReplacementBytes))
}
